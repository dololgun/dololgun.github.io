# redis data type

[출처] http://redis.io/topics/data-types-intro

* Binary-safe strings : 
* Lists : 입력된 순서데로 정렬된 문자 요소 
* Sets : 중복불가능한 데터집합
* Sorted sets : score로 명명된 숫자 값으로 정렬된 sets

#### redis keys
 * binary safe 하다. 이게 무슨 말인가? 
 * 어떤 바이너리 시퀀스도 키로 사용할 수 있다.  ("foo"라는 문자부터 JPEG파일의 내용까지). 빈 문자열도 물론 가능.
 * 몇 가지 다른 rule도 존재한다. 
	 * 

#### redis strings
가장 단순한 value 형식이다. 아래와 같이 string 타입의 value를 저장하고 조회해 보자. 

```
> set mykey somevalue
ok
> get mykey
"somevalue"
```

`set`과 `get`이 값을 저장하고 불러오는(retrive) 핵심 명령어다. 'set'명령어는 이미 존재하는 key와 value가 있다면 overwrite함에 유의하자. 값은 어떤 타입도 가능하지만 크기는 512MB보다 클 수 없다. 

`set` 명령어의 옵션
  `nx` : key가 이미 존재하면 오류 
  `xx` : key가 존재하지 않으면 x
  `ex` : expire tim을 설정

값이 문자열이지만 다양한 동작이 가능하다. 
#### 원자 증가
```
> set counter 100
> incr counter
> incrby counter 50
```
`incr`명령어는 문자값을 숫자로 변환하고 1을 증가시킨다. 같은 유형의 명령어가 다음과 같이 존재한다. 

`incrby`, `decr`, `decrby`

원자성을 보장한다는 의미는 멀티 상황에서도 경합조건이 발생하지 않는다는 것이다. 이것으로 스레드에 안전한 구현을 할 수 있다. 

`getset` 명령어는 key에 newvalue를 세팅하고 oldvalue를 리턴한다. 이것은 지속적으로 증가하다가 특정 순간에 초기화 시킬경우 활용된다. 

`mset`, `mget`은 다수의 키와 값을 저장할 때 사용된다. 

`exists`는 키가 존재하면 1, 존재하지 않으면 0을 리턴한다. 

`del`은 키-값을 삭제하며 키가 있어 삭제했다면 1, 키가 없어서 못했다면 0을 출력한다. 

`type`키와 연결된 값의 종류를 출력한다. 

`expire` 특정 시간(초)이 지난 후 key가 사라진다. 

`persist`: 키의 expire time을 제거한다.

`ttl`: 키의 남은 유효시간을 확인한다.

#### redis list

일반적인 관점에서 리스트는 어떤 요소들의 순차적인 집합이다. 배열을 사용한 리스트의 속성과 링크드리스트를 사용한 리스트의 속성은 꽤 다른다. 레디스의 리스트는 링크드 리스트로 구현되어 있다. 

> 링크드 리스트의 특징은 새로운 요소를 맨앞이나 맨뒤에 추가 할 때 요소의 갯수와 상관없이 일정하다. 링크드 리스트의 단점은 요소 인덱스로 접근할때 빠르지 않다. 데이터베이스 시스템에서는 다량의 데이터에서 신규데이터를 빠르게 입력하는 것이 중요하기 때문에 링크드 리스트를 사용한다. 

`lpush` : 리스트왼쪽(머리)에 요소를 추가한다.
`rpush` : 리스트오른쪽(꼬리)에 요소를 추가한다.
`lrange`: 리스트를 추출한다.

중요한 것은 pop엘리먼트이다. 이 명령어는 요소를 가져옴과 동시에 제거한다. pop은 왼쪽에서 오른쪽으로 동작한다.

리스트가 유요한 곳
* 가장 최근 포스트를 기억하는 것
* 생산자 - 소비자 아키텍처에서 사용 : 생상자는 push하고 소비자는 pop하는 형태 - 카프카 처럼 사용하는 것 

#### capped lists

* 가장 최근 데이터 N건만 저장하고 나머지는 버리는 리스트
* 버릴때는 `ltrim`명령어를 사용한다.

```
> rpush mylist 1 2 3 4 5
(integer) 5
> ltrim mylist 0 2
OK
> lrange mylist 0 -1
1) "1"
2) "2"
3) "3"
```

#### blocking operation on lists

생상자 - 소비자 패턴에서 사용된다. 이 패턴에서 폴링방식의 비효율적인 문제가 있는데 이것을 해결하기 위해 brpop, blpop명령어를 구현했다. 만약에 리스트가 비었다면 pop을 시도하지않고 리스트에 요소가 추가되면 pop을 수행한다. 

```
> brpop tasks 5
1) "tasks"
2) "do_something"
```

리턴값은 키 밸류이다. 

#### 키의 자동생성과 삭제

리스트 뿐만 아니라 모든 키는 빈 값을 가진 채로 존재 하지 않는다. 

이것과 관련한 기본 3가지 룰이 있다. 

1. 집합 데이터를 추가할 때 자동으로 키가 생성된다.
2. 집합 데이터를 삭제할 때 집합요소가 없다면 키가 삭제된다. 
3. 빈 키를 대상으로 명령을 내릴 때도 키가 있을 때 처럼 동작한다. 